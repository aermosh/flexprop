<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Total Spectrum Software" />
  <meta name="dcterms.date" content="2023-01-13" />
  <title>FlexSpin Language Reference</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      word-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">FlexSpin Language Reference</h1>
<p class="subtitle">5.9.25-beta</p>
<p class="author">Total Spectrum Software</p>
<p class="date">01/13/2023</p>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#flexspin-spin">Flexspin Spin</a>
<ul>
<li><a href="#introduction">Introduction</a>
<ul>
<li><a href="#see-also">See also</a></li>
</ul></li>
<li><a href="#preprocessor">Preprocessor</a>
<ul>
<li><a href="#directives">Directives</a></li>
<li><a href="#predefined-symbols">Predefined Symbols</a></li>
<li><a href="#special-preprocessor-comments">Special Preprocessor Comments</a></li>
</ul></li>
<li><a href="#memory-management">Memory Management</a>
<ul>
<li><a href="#heap-allocation">Heap allocation</a></li>
<li><a href="#stack-allocation">Stack allocation</a></li>
</ul></li>
<li><a href="#interoperation-with-c-and-basic">Interoperation with C and BASIC</a>
<ul>
<li><a href="#calling-c-standard-library-functions">Calling C standard library functions</a></li>
</ul></li>
<li><a href="#extensions-to-spin">Extensions to Spin</a>
<ul>
<li><a href="#absolute-address">Absolute address</a></li>
<li><a href="#access-to-member-variables">Access to member variables</a></li>
<li><a href="#alternate-string-notation">Alternate string notation</a></li>
<li><a href="#bitfield-access">Bitfield access</a></li>
<li><a href="#boolean-short-circuit-operators">Boolean short-circuit operators</a></li>
<li><a href="#case_fast">CASE_FAST</a></li>
<li><a href="#coginitcognew">coginit/cognew</a></li>
<li><a href="#conditional-expressions">Conditional expressions</a></li>
<li><a href="#continuing-lines-with-">Continuing lines with ...</a></li>
<li><a href="#default-function-parameters">Default function parameters</a></li>
<li><a href="#function-aliases">Function Aliases</a></li>
<li><a href="#inline-assembly-with-asmend">Inline assembly with asm/end</a></li>
<li><a href="#spin2-style-inline-assembly-orgend">Spin2 style inline assembly (org/end)</a></li>
<li><a href="#method-pointers">Method pointers</a></li>
<li><a href="#multiple-return-values-and-assignments">Multiple return values and assignments</a></li>
<li><a href="#object-parameters">Object parameters</a></li>
<li><a href="#object-pointers">Object pointers</a></li>
<li><a href="#pub-file-and-pri-file">PUB FILE and PRI FILE</a></li>
<li><a href="#typed-parameters-and-return-values">Typed parameters and return values</a></li>
<li><a href="#typed-local-variables">Typed local variables</a></li>
<li><a href="#unsigned-operators">Unsigned operators</a></li>
<li><a href="#additional-spin2-operators">Additional Spin2 operators</a></li>
<li><a href="#new-operators">New operators</a></li>
<li><a href="#array-parameters-deprecated">Array parameters (deprecated)</a></li>
</ul></li>
<li><a href="#new-pasm-directives">New PASM directives</a>
<ul>
<li><a href="#orgf">ORGF</a></li>
<li><a href="#orgh">ORGH</a></li>
</ul></li>
<li><a href="#new-intrinsics-for-both-p1-and-p2">New intrinsics for both P1 and P2</a>
<ul>
<li><a href="#_pinw">_PINW</a></li>
<li><a href="#_pinl">_PINL</a></li>
<li><a href="#_pinh">_PINH</a></li>
<li><a href="#_pinnot">_PINNOT</a></li>
<li><a href="#_waitx">_WAITX</a></li>
</ul></li>
</ul></li>
<li><a href="#compatibility-with-other-spin-1-compilers">Compatibility with other Spin 1 compilers</a>
<ul>
<li><a href="#limitations">Limitations</a></li>
<li><a href="#known-differences">Known Differences</a>
<ul>
<li><a href="#timing">Timing</a></li>
<li><a href="#-and--operator-address-truncation">@ and @@ Operator address truncation</a></li>
<li><a href="#chipver">CHIPVER</a></li>
</ul></li>
<li><a href="#symbol-differences">Symbol Differences</a>
<ul>
<li><a href="#local-variables-may-shadow-method-names">Local variables may shadow method names</a></li>
<li><a href="#special-characters-in-identifiers">Special characters in identifiers</a></li>
<li><a href="#opcodes">Opcodes</a></li>
<li><a href="#reserved-words">Reserved words</a></li>
</ul></li>
<li><a href="#strings">Strings</a></li>
<li><a href="#known-bugs">Known Bugs</a>
<ul>
<li><a href="#type-narrowing-in-assignment">Type narrowing in assignment</a></li>
</ul></li>
</ul></li>
<li><a href="#p2-considerations">P2 Considerations</a>
<ul>
<li><a href="#spin1-on-p2">Spin1 on P2</a></li>
<li><a href="#compatibility-with-proptool">Compatibility with PropTool</a>
<ul>
<li><a href="#layout-of-variables-in-memory">Layout of variables in memory</a></li>
<li><a href="#expressions-involving-">Expressions involving <code>:</code></a></li>
<li><a href="#-operator">@ Operator</a></li>
<li><a href="#orgend">ORG/END</a></li>
<li><a href="#memory-map">Memory map</a></li>
<li><a href="#debug-statements">DEBUG statements</a></li>
<li><a href="#asmclk-instruction">ASMCLK instruction</a></li>
<li><a href="#regloadregexec">REGLOAD/REGEXEC</a></li>
<li><a href="#detecting-flexspin-versus-pnut">Detecting FlexSpin versus PNut</a></li>
</ul></li>
</ul></li>
</ul>
</nav>
<h1 id="flexspin-spin">Flexspin Spin</h1>
<h2 id="introduction">Introduction</h2>
<p>Flexspin was designed to accept the language Spin as documented in the Parallax Propeller Manual. It should be able to compile most Spin programs, as long as there is space. The restriction is an important one; other Spin compilers produce Spin bytecode, a compact form that is interpreted by a program in the Propeller's ROM. Flexspin produces LMM code, which is basically a slightly modified Propeller machine code (slightly modified to run in HUB memory instead of COG). This is much larger than Spin bytecode, but also much, much faster.</p>
<p>Flexspin is able to produce binaries for both the P1 and P2 chips. Any assembly language written in DAT sections (or inside inline ASM blocks) must be for the appropriate chip; it will not be translated.</p>
<p>Flexspin also supports many of the features of the Spin2 language as extensions to Spin 1. It can also accept Spin2 programs as input. Spin1 and Spin2 are not completely compatible. Spin2 features which are not compatible with Spin1 are enabled if the file extension is <code>.spin2</code>.</p>
<h3 id="see-also">See also</h3>
<p>Please see also the general compiler features documentation ("general.pdf" or "general.md") which describes common features of the compiler and of the other languages supported by the compiler.</p>
<h2 id="preprocessor">Preprocessor</h2>
<p>flexspin has a pre-processor that understands basic directives like <code>#include</code>, <code>#define</code>, and<code>#ifdef / #ifndef / #else / #endif</code>.</p>
<h3 id="directives">Directives</h3>
<h4 id="define">#DEFINE</h4>
<pre><code>#define FOO hello</code></pre>
<p>Defines a new macro <code>FOO</code> with the value <code>hello</code>. Whenever the symbol <code>FOO</code> appears in the text, the preprocessor will substitute <code>hello</code>.</p>
<p>Note that unlike the C preprocessor, this one cannot accept arguments in macros. Only simple defines are permitted.</p>
<p>If no value is given, e.g.</p>
<pre><code>#define BAR</code></pre>
<p>then the symbol is defined as the string <code>1</code>.</p>
<h4 id="ifdef">#IFDEF</h4>
<p>Introduces a conditional compilation section, which is only compiled if the symbol after the <code>#ifdef</code> is in fact defined. For example:</p>
<pre><code>#ifdef __P2__
&#39;&#39; propeller 2 code goes here
#else
&#39;&#39; propeller 1 code goes here
#endif</code></pre>
<h4 id="ifndef">#IFNDEF</h4>
<p>Introduces a conditional compilation section, which is only compiled if the symbol after the <code>#ifndef</code> is <em>not</em> defined. For example:</p>
<pre><code>#ifndef __P2__
#error this code only works on Propeller 2
#endif</code></pre>
<h4 id="else">#ELSE</h4>
<p>Switches the meaning of conditional compilation.</p>
<h4 id="elseifdef">#ELSEIFDEF</h4>
<p>A combination of <code>#else</code> and <code>#ifdef</code>.</p>
<h4 id="elseifndef">#ELSEIFNDEF</h4>
<p>A combination of <code>#else</code> and <code>#ifndef</code>.</p>
<h4 id="error">#ERROR</h4>
<p>Prints an error message. Mainly used in conditional compilation to report an unhandled condition. Everything after the <code>#error</code> directive is printed.</p>
<h4 id="include">#INCLUDE</h4>
<p>Includes a file.</p>
<h4 id="warn">#WARN</h4>
<p>Prints a warning message.</p>
<h4 id="undef">#UNDEF</h4>
<p>Removes the definition of a symbol, e.g. to undefine <code>FOO</code> do:</p>
<pre><code>#undef FOO</code></pre>
<h3 id="predefined-symbols">Predefined Symbols</h3>
<p>There are several predefined symbols:</p>
<table>
<thead>
<tr class="header">
<th>Symbol</th>
<th>When Defined</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>__propeller__</code></td>
<td>always defined to 1 (for P1) or 2 (for P2)</td>
</tr>
<tr class="even">
<td><code>__propeller2__</code></td>
<td>if compiling for Propeller 2</td>
</tr>
<tr class="odd">
<td><code>__P2__</code></td>
<td>if compiling for Propeller 2</td>
</tr>
<tr class="even">
<td><code>__FLEXSPIN__</code></td>
<td>if the <code>flexspin</code> front end is used</td>
</tr>
<tr class="odd">
<td><code>__SPINCVT__</code></td>
<td>always defined</td>
</tr>
<tr class="even">
<td><code>__SPIN2PASM__</code></td>
<td>if --asm is given (PASM output) (always defined by flexspin)</td>
</tr>
<tr class="odd">
<td><code>__SPIN2CPP__</code></td>
<td>if C++ or C is being output (never in flexspin)</td>
</tr>
<tr class="even">
<td><code>__HAVE_FCACHE__</code></td>
<td>if the FCACHE optimization is enabled</td>
</tr>
<tr class="odd">
<td><code>__cplusplus</code></td>
<td>if C++ is being output (never in flexspin)</td>
</tr>
<tr class="even">
<td><code>__DATE__</code></td>
<td>a string containing the date when compilation was begun</td>
</tr>
<tr class="odd">
<td><code>__FILE__</code></td>
<td>a string giving the current file being compiled</td>
</tr>
<tr class="even">
<td><code>__LINE__</code></td>
<td>the current source line number</td>
</tr>
<tr class="odd">
<td><code>__TIME__</code></td>
<td>a string containing the time when compilation was begun</td>
</tr>
<tr class="even">
<td><code>__VERSION__</code></td>
<td>a string containing the full version of flexspin in use</td>
</tr>
<tr class="odd">
<td><code>__DEBUG__</code></td>
<td>if debugging is enabled (-g or -gbrk given)</td>
</tr>
</tbody>
</table>
<p>A predefined symbol is also generated for type of output being created:</p>
<table>
<thead>
<tr class="header">
<th>Symbol</th>
<th>When Defined</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>__OUTPUT_ASM__</code></td>
<td>if PASM code is being generated</td>
</tr>
<tr class="even">
<td><code>__OUTPUT_BYTECODE__</code></td>
<td>if bytecode is being generated</td>
</tr>
<tr class="odd">
<td><code>__OUTPUT_C__</code></td>
<td>if C code is being generated</td>
</tr>
<tr class="even">
<td><code>__OUTPUT_CPP__</code></td>
<td>if C++ code is being generated</td>
</tr>
</tbody>
</table>
<h3 id="special-preprocessor-comments">Special Preprocessor Comments</h3>
<p>If the preprocessor sees the special comment <code>{$flexspin</code> at the beginning of a line, it will re-process the rest of the comment as input. This allows flexspin specific code to be placed in such comments. For example, you could do:</p>
<pre><code>CON
  _clkfreq = 160_000_000

PUB main()
  repeat
{$flexspin
#ifdef __FLEXSPIN__
    DEBUG(&quot;hello from flexspin&quot;, 13, 10)
#else
}
    DEBUG(&quot;hello from PNut&quot;, 13, 10)
{$flexspin #endif}
    DEBUG(&quot;hello from both&quot;, 13, 10)</code></pre>
<h2 id="memory-management">Memory Management</h2>
<p>There are some built in functions for doing memory allocation. These are intended for C or BASIC, but may be used by Spin programs as well.</p>
<h3 id="heap-allocation">Heap allocation</h3>
<p>The main function is <code>_gc_alloc_managed(siz)</code>, which allocates <code>siz</code> bytes of memory managed by the garbage collector. It returns 0 if not enough memory is avilable, otherwise returns a pointer to the start of the memory (like C's <code>malloc</code>). As long as there is some reference in COG or HUB memory to the pointer which got returned, the memory will be considered "in use". If there is no more such reference then the garbage collector will feel free to reclaim it. There's also <code>_gc_alloc(siz)</code> which is similar but marks the memory so it will never be reclaimed, and <code>_gc_free(ptr)</code> which explicitly frees a pointer previously allocated by <code>_gc_alloc</code> or <code>_gc_alloc_managed</code>.</p>
<p>The size of the heap is determined by a constant <code>HEAPSIZE</code> declared in the top level object. If none is given then a (small) default value is used.</p>
<p>Example:</p>
<pre><code>&#39; put this CON in the top level object to specify how much memory should be provided for
&#39; memory allocation (the &quot;heap&quot;). The default is 4K on P2, 256 bytes on P1
CON
   HEAPSIZE = 32768 &#39; or however much memory you want to provide for the allocator

&#39; here&#39;s a function to allocate memory
&#39; &quot;siz&quot; is the size in bytes
PUB allocmem(size) : ptr
  ptr := _gc_alloc_managed(size)</code></pre>
<p>The garbage collection functions and heap are only included in programs which explicitly ask for them.</p>
<h3 id="stack-allocation">Stack allocation</h3>
<p>Temporary memory may be allocated on the stack by means of the call <code>__builtin_alloca(siz)</code>, which allocates <code>siz</code> bytes of memory on the stack. This is like the C <code>alloca</code> function. Note that the pointer returned by <code>__builtin_alloca</code> will become invalid as soon as the current function returns, so it should not be placed in any global variable (and definitely should not be returned from the function!)</p>
<h2 id="interoperation-with-c-and-basic">Interoperation with C and BASIC</h2>
<p>C and BASIC files may be included as objects in Spin1 and Spin2 programs. To do this, be sure to include the entire file name (including any extension, like <code>.c</code> or <code>.bas</code>) in the <code>OBJ</code> line.</p>
<p>Note that C is a case sensitive language, so you must use the exact same name that C uses: if <code>VGA</code> is a constant defined in a C file <code>video.c</code> then it must be used always as all upper case, not as <code>Vga</code> or <code>vga</code>. For example:</p>
<pre><code>OBJ
  screen: &quot;video.c&quot;
...
  x := screen.VGA  &#39; this is fine
  x := screen.Vga  &#39; this is an error, the case does not match</code></pre>
<h3 id="calling-c-standard-library-functions">Calling C standard library functions</h3>
<p>A simple way to include the C standard library is to declare an object using <code>libc.a</code>. C standard library functions may then be accessed as methods of that object. For example, to call <code>sprintf</code> you could do:</p>
<pre><code>OBJ
  c: &quot;libc.a&quot;
...
  c.sprintf(@buf, string(&quot;the value is %x&quot;, 10), val)</code></pre>
<h2 id="extensions-to-spin">Extensions to Spin</h2>
<p>Flexspin has a number of extensions to the Spin languages (both Spin1 and Spin2). Many Spin2 features may be used in Spin1, and vice-versa. For example in Spin2 functions with no arguments must be called like <code>foo()</code>, whereas flexspin still accepts the Spin1 version <code>foo</code>.</p>
<h3 id="absolute-address">Absolute address</h3>
<p>The <code>@@@</code> operator returns the absolute hub address of a variable. This is the same as <code>@</code> in Spin code, but in PASM code <code>@</code> returns only the address relative to the start of the <code>DAT</code> section.</p>
<h3 id="access-to-member-variables">Access to member variables</h3>
<p>Flexspin allows (read only) access to member variables and constants using the <code>.</code> notation. That is, if <code>S</code> is an object like:</p>
<pre><code>CON
  rows = 24
VAR
  long x, y</code></pre>
<p>then one may write <code>S.x</code> to access member variable <code>x</code> of <code>S</code>, and <code>S.rows</code> to access the constant <code>rows</code>. The original Spin syntax <code>S#rows</code> is still accepted for accessing constants.</p>
<p>Modifying member variables of another object directly is not permitted, and will produce a syntax error.</p>
<h3 id="alternate-string-notation">Alternate string notation</h3>
<p>Flexspin interprets the notation <code>@"some chars"</code> to mean the same thing as <code>STRING("some chars")</code>. This provides a shorter way to write some messages. Newer versions of PNut / PropTool allow this for Spin2.</p>
<h3 id="bitfield-access">Bitfield access</h3>
<p>Bits <code>m</code> to <code>n</code> of a variable <code>x</code> may be accessed via the notation <code>x.[m..n]</code>. If <code>m</code> is the same as <code>n</code> this may be simplified to <code>x.[n]</code>. This notation may also be applied to hardware registers.</p>
<h3 id="boolean-short-circuit-operators">Boolean short-circuit operators</h3>
<p>flexspin has operators <code>x __andthen__ y</code> and <code>x __orelse__ y</code> which only evaluate the right hand side (<code>y</code>) if they need to (like C's <code>&amp;&amp;</code> and <code>||</code>). Ordinary boolean <code>AND</code> and <code>OR</code> operators will be optimized to these in the cases where <code>x</code> and <code>y</code> do not have side effects.</p>
<h3 id="case_fast">CASE_FAST</h3>
<p><code>CASE_FAST</code> is just like <code>CASE</code>, except that each of the case items must be a constant expression. It is guaranteed to compile to a jump table (regular <code>CASE</code> may sometimes compile to a sequence of <code>IF</code>/<code>ELSE IF</code>).</p>
<h3 id="coginitcognew">coginit/cognew</h3>
<p>The <code>coginit</code> (and <code>cognew</code>) functions in Flexspin can start functions from other objects than the current. (In "regular" Spin only functions from the same object may be started this way.)</p>
<h3 id="conditional-expressions">Conditional expressions</h3>
<p>IF...THEN...ELSE expressions; you can use IF/THEN/ELSE in an expression, like:</p>
<pre><code>r := if a then b else c</code></pre>
<p>which is the same as</p>
<pre><code>   if a then
     r := b
   else
     r := c</code></pre>
<p>This may also be written in C / Verilog style as:</p>
<pre><code>r := (a) ? b : c</code></pre>
<p>In the latter form the parentheses around <code>a</code> are mandatory in Spin1 to avoid confusion with the random number operator <code>?</code>. In Spin2 the question mark is no longer used for random numbers, so the issue does not arise there.</p>
<h3 id="continuing-lines-with-">Continuing lines with ...</h3>
<p>If a source line ends with <code>...</code> then the following newline is ignored for parsing purposes. This allows one to break long or complicated expressions over multiple lines, for example:</p>
<pre><code>DAT
    word  x +      ...
          (y&lt;&lt;4) + ...
      (z&lt;&lt;5)</code></pre>
<p>is equivalent to</p>
<pre><code>DAT
    word  x + (y&lt;&lt;4) + (z&lt;&lt;5)</code></pre>
<p>In fact the <code>...</code> does not actually have to be the last thing on the line, although that is the recommended style; whenever <code>...</code> is seen the rest of the line, including the final newline, is ignored.</p>
<h3 id="default-function-parameters">Default function parameters</h3>
<p>flexspin permits function parameters to be given default values by adding <code>= X</code> after the parameter declaration, where <code>X</code> is a constant expression. For instance:</p>
<pre><code>VAR
  long a

PUB inc(n=1)
  a += n

PUB main
  inc(2) &#39; adds 2 to a
  inc(1) &#39; adds 1 to a
  inc    &#39; same as inc(1)
  </code></pre>
<p>The default values must, for now, be constant. Perhaps in the future this restriction will be relaxed, but there are some slightly tricky issues involving variable scope that must be resolved first.</p>
<h4 id="default-string-parameters">Default string parameters</h4>
<p>If a default function parameter is declared as a string, and a string literal is passed to it, that string literal is transformed into a string constant. Normally Spin uses just the first character of a string literal when one is seen in an expression (outside of STRING). Basically flexspin inserts a <code>string</code> operator around the literal in this case. So for example in:</p>
<pre><code>PUB write(msg = string(&quot;&quot;))
  &#39;&#39; do some stuff
...
  write(string(&quot;hello, world&quot;))
  write(&quot;hello, world&quot;)</code></pre>
<p>the two calls to <code>write</code> will do the same thing. In regular Spin, and in flexspin in the case where the default value is not present on a parameter, the second call will actually be interpreted as:</p>
<pre><code>  write($68, $65, ..., 0)  &#39; $68 = ASCII value of &quot;h&quot;</code></pre>
<p>which is probably not what was intended.</p>
<h3 id="function-aliases">Function Aliases</h3>
<p>A function may have an "alias" created for it. That is, if you want to be able to call the same function by two different names <code>add</code> and <code>_add</code>, you can do:</p>
<pre><code>PUB _add(x, y)
  return x+y
PUB add = _add</code></pre>
<p>The <code>PUB add = _add</code> line says that <code>add</code> is an alias for <code>_add</code>.</p>
<p>Aliases defined this way are "weak"; that is, they may be overridden by later definitions. They are mostly intended for use in libraries where for some reason (e.g. C standard compatibility) we wish to allow the program to use the same name as a library function without a conflict occuring.</p>
<h3 id="inline-assembly-with-asmend">Inline assembly with asm/end</h3>
<p>flexspin accepts inline assembly in <code>PUB</code> and <code>PRI</code> sections. Inline assembly starts with <code>asm</code> and ends with <code>endasm</code>. The inline assembly is somewhat limited; the only operands permitted are immediate values, hardware registers like <code>OUTA</code>, local variables (including parameters and result values) of the containing function, or labels of that function. (Spin doesn't support goto and labels, but you can define labels in <code>asm</code> blocks and jump to them from other <code>asm</code> blocks that are in the same function. Some other languages supported by flexspin do have labels.) Member variables (declared in the <code>VAR</code> block) may not be used directly in inline assembly.</p>
<p>Branching inside the function should work, but trying to return from it or to otherwise jump outside the function will almost certainly cause you to come to grief, even if the compiler allows it. Calling subroutines is also not permitted.</p>
<p>All non-branch instructions should work properly in inline assembly, as long as the operands satisfy the constraints above. Conditional execution is allowed, and flag bits may be set and tested.</p>
<p>If you need temporary variables inside some inline assembly, declare them as locals in the enclosing function.</p>
<p>Example:</p>
<pre><code>PUB waitcnt2(newcnt, incr)
  asm
    waitcnt newcnt, incr
  endasm
  return newcnt</code></pre>
<p>waits until CNT reaches "newcnt", and returns "newcnt + incr".</p>
<p>Note that unlike most Spin blocks, the <code>asm</code> block has to end with <code>endasm</code>. This is because indentation is not significant inside the assembly code. For example, labels typically start at the leftmost margin.</p>
<h3 id="spin2-style-inline-assembly-orgend">Spin2 style inline assembly (org/end)</h3>
<p>flexspin also accepts Spin2 style inline assembly, marked with <code>org</code> and <code>end</code> instead of <code>asm</code> and <code>endasm</code>. So the above example could be written as:</p>
<pre><code>PUB waitcnt2(newcnt, incr)
  org
    waitcnt newcnt, incr
  end
  return newcnt</code></pre>
<p>There are two important differences between <code>org</code>/<code>end</code> and <code>asm</code>/<code>endasm</code>:</p>
<p>(1) Normally inline assembly is treated the same as code generated by the compiler, and subject to optimization. However, code between <code>org</code> and <code>end</code> is not optimized. So if your inline assembly is timing sensitive, you should use <code>org</code> rather than <code>asm</code> to start it.</p>
<p>(2) Code between <code>org</code> and <code>end</code> is executed from the FCACHE area (in COG memory). Ordinary <code>asm</code> is hubexec.</p>
<h4 id="differences-from-proptoolpnut">Differences from PropTool/PNut</h4>
<p>Unlike the "official" Spin2 compiler, flexspin does not accept an address for the inline assembly ("org $xxx"), and the assembly is not called as a subroutine (so no <code>ret</code> statement should be included). There are also some important restrictions in flexspin's implementation:</p>
<p>(1) <code>call</code> instructions may not be used in inline assembly</p>
<p>(2) The <code>ptra</code> register must not be modified by the inline assembly.</p>
<p>(3) The area set aside for inline assembly is smaller by default in flexspin than in Parallax's Spin2. This may be changed with the --fcache parameter to flexspin.</p>
<p>(4) In PNut/PropTool only the first 16 local variables may be accessed in inline assembly; flexspin does not have this restriction.</p>
<h3 id="method-pointers">Method pointers</h3>
<p>Pointers to methods may be created with <code>@</code> and called using the normal calling syntax. For example:</p>
<pre><code>VAR
  LONG funcptr
  
PUB twice(x) : r
  r := x + x
...
  funcptr := @twice
  y := funcptr(a)</code></pre>
<p>will set <code>y</code> to <code>a+a</code>.</p>
<p>If no parameters are to be passed to the called function, it is still necessary to write <code>()</code> after it in order to force it to be interpreted as a call. That is,</p>
<pre><code>a = f()</code></pre>
<p>causes an indirect call of the function pointed to by <code>f</code>, whereas</p>
<pre><code>a = f</code></pre>
<p>copies the pointer in <code>f</code> to <code>a</code>.</p>
<p>For functions returning multiple results, a <code>:N</code> notation is required after the function call, where <code>N</code> is an integer giving the expected number of results:</p>
<pre><code>  x,y := fptr(a):2</code></pre>
<p>The <code>:2</code> indicates that fptr is a pointer to a function which returns 2 results. Putting <code>:0</code> or <code>:1</code> for functions which return 0 or 1 results is optional in flexspin.</p>
<p>It is the programmer's responsibility to make sure that the number of results and arguments passed to a method called via a pointer are correct. No type checking is done.</p>
<h3 id="multiple-return-values-and-assignments">Multiple return values and assignments</h3>
<p>flexspin allows multiple return values and assignments. For example, to swap two variables <code>a</code> and <code>b</code> you can write:</p>
<pre><code>  a,b := b,a</code></pre>
<p>It's also acceptable (and perhaps easier to read) if there are parentheses around some or all of the multiple values:</p>
<pre><code>  (a,b) := (b,a)</code></pre>
<p>A function can also return multiple values. For instance, a function to calculate both a quotient and remainder could be written as:</p>
<pre><code>PUB divrem(x,y)
  return x/y, x//y</code></pre>
<p>or</p>
<pre><code>PUB divrem(x,y) : q, r
  q := x/y
  r := x//y</code></pre>
<p>This could later be used like:</p>
<pre><code>  (a,digit) := divrem(a, 10)</code></pre>
<p>It is also allowed to pass the multiple values returned from one function to another. So for example:</p>
<pre><code>&#39; function to double a 64 bit number
PUB dbl64(ahi, alo): bhi, blo
  bhi := ahi
  blo := alo
  asm
    add blo, blo wc
    addx bhi, bhi
  endasm

&#39; function to quadruple a 64 bit number
PUB quad64(ahi, alo)
  return dbl64(dbl64(ahi, alo))</code></pre>
<h3 id="object-parameters">Object parameters</h3>
<p>Constants declared within an object may be overridden when an object is instantiated. For example, in</p>
<pre><code>OBJ
  A : &quot;mypins&quot;
  B : &quot;mypins&quot; | PIN_I2C = 4, PIN_SPI = 8</code></pre>
<p>the value of <code>A#PIN_I2C</code> is the default for the mypins object, but the value of <code>B#PIN_I2C</code> will be 4. This may be useful for providing buffer sizes, or for overriding default settings in an object. Note that if an object is given parameters, a completely new copy of the object will be created, including new copies of all methods in the object. Normally if multiple objects come from the same file they can share their code and DAT sections, but this is not the case for parameterized objects.</p>
<h3 id="object-pointers">Object pointers</h3>
<p>The proposed Spin2 syntax for abstract object definitions and object pointers is accepted by flexspin, even in Spin1 mode. A declaration like:</p>
<pre><code>OBJ
  fds = &quot;FullDuplexSerial&quot;</code></pre>
<p>declares <code>fds</code> as having the methods of a FullDuplexSerial object, but without any actual variable or storage being instantiated. Symbols declared this way may be used to cast parameters to an object type, for example:</p>
<pre><code>PUB print(f, c)
  fds[f].dec(c)

PUB doprint22
  print(@aFullDuplexSerialObj, 22)</code></pre>
<h3 id="pub-file-and-pri-file">PUB FILE and PRI FILE</h3>
<p>A <code>pub</code> or <code>pri</code> function declaration may include a <code>file</code> directive which gives the file which contains the actual definition of the function. This looks like:</p>
<pre><code>  pub file &quot;utils.spin&quot; myfunc(x, y)</code></pre>
<p>This declares a function <code>myfunc</code> with two parameters, which will be loaded from the file "utils.spin". The function will be a public function of the object. This provides an easy way to import the same function (e.g. a decimal conversion routine) into many different objects.</p>
<p><code>pub file</code> and <code>pri file</code> differ from the <code>obj</code> directive in that they do not create a new object; the functions defined in the new file are part of the current object.</p>
<p>Note that there is no need for a body to the function (it is an error to give one). The number of parameters and return values, however, should be specified; they must match the number given in the final definition contained in the file.</p>
<p>The function body need not be in Spin. For example, to use the C <code>atoi</code> function in a Spin object on a Propeller1, you could do:</p>
<pre><code>obj ser: &quot;spin/FullDuplexSerial.spin&quot;
pub file &quot;libc/stdlib/atoi.c&quot; atoi(str)

pub test
  ser.start(31, 30, 0, 115_200)
  x := string(&quot;1234&quot;)
  ser.dec(atoi(x))</code></pre>
<p>(For Propeller2 you would have to modify this to use "spin/SmartSerial" and to change the output pins appropriately.)</p>
<p>Beware that functions declared with <code>file</code> are treated the same as other functions; in particular, note that the first function in the top level object will be used as the starting point for the program, even if that function was declared with <code>pub file</code> or <code>pri file</code>. So unlike in C, the declaration of external functions should be placed at the end of the file rather than the beginning (unless for some reason you want the main program to come from another file).</p>
<h3 id="typed-parameters-and-return-values">Typed parameters and return values</h3>
<p>The "expression" in a default parameter may also be a type name, for example <code>long</code>, <code>float</code>, a flag indicating an unsigned type <code>+long</code>, (or one of the pointer types <code>@long</code> (pointer to long), <code>@word</code> (pointer to word), <code>@byte</code>, or <code>@float</code>. These do not provide a default value, but do provide a hint to the compiler about what type of value is expected. This isn't terribly useful for Spin, but does make it possible for the compiler to check types and/or convert them if necessary for Spin functions called from C or BASIC.</p>
<p>Variables declared as return values may also be given type hints, which will be used to determine the type of the function when it is accessed from another language.</p>
<p>Example:</p>
<pre><code>&#39; negate a floating point value
PUB negfloat(x = float) : r = float
  r := x ^ $80000000</code></pre>
<h3 id="typed-local-variables">Typed local variables</h3>
<p>As in Spin2, local variables may be declared prefixed with <code>byte</code>, <code>word</code>, or <code>long</code> to give them a specific size.</p>
<p>Example:</p>
<pre><code>PUB dostuff(x) : r | byte tempstring[10]
 &#39; may use tempstring here as an array</code></pre>
<h3 id="unsigned-operators">Unsigned operators</h3>
<p>flexspin has some new operators for treating values as unsigned</p>
<pre><code>  a +/ b   is the unsigned quotient of a and b (treating both as unsigned)
  a +// b  is the unsigned remainder of a and b
  a +** b  gives the upper 32 bits of unsigned multiplication
  a +&lt; b   is an unsigned version of &lt;
  a +&gt; b   is an unsigned version of &gt;
  a +=&lt; b  is an unsigned version of =&lt;
  a +=&gt; b  is an unsigned version of =&gt;</code></pre>
<p>Most of these are also in Spin2.</p>
<h3 id="additional-spin2-operators">Additional Spin2 operators</h3>
<p>flexspin accepts some other Spin2 operators:</p>
<pre><code>  a \ b   uses the value of a, but then sets a to b
  x &lt;=&gt; y returns -1, 0, or 1 if x &lt; y, x == y, or x &gt; y</code></pre>
<h3 id="new-operators">New operators</h3>
<p>flexspin implements some new operators:</p>
<pre><code>  a +| b  is the same as a ZEROX b in Spin2
  a -| b  is the same as a SIGNX b in Spin2</code></pre>
<h3 id="array-parameters-deprecated">Array parameters (deprecated)</h3>
<p>flexspin allows method parameters to be small arrays; in this case, the caller must supply one argument for each element of the array. For example:</p>
<pre><code>pub selector(n, a[4])
  return a[n]

pub tryit
  return selector(n, 1, 2, 3, 4)</code></pre>
<p>This particular example could be achieved via <code>lookup</code>, but there are other cases where it might be convenient to bundle parameters together in an array.</p>
<p>This feature is still incomplete, and may not work properly for C/C++ output.</p>
<h2 id="new-pasm-directives">New PASM directives</h2>
<p>flexspin accepts some Spin2 assembly directives, even in Spin1 mode.</p>
<h3 id="orgf">ORGF</h3>
<p>Forces the COG PC to reach a certain value by inserting 0 if necessary. For example, <code>orgf $100</code> will insert 0 bytes until the COG program counter reaches $100. <code>orgf X</code> is basically similar to:</p>
<pre><code>   long 0[X - $]</code></pre>
<p>ORGF is valid only in COG space.</p>
<h3 id="orgh">ORGH</h3>
<p>Specifies that labels and code after this must be in HUB memory.</p>
<pre><code>   orgh   &#39; following code must be in HUB
   orgh $400 &#39; following code must be in HUB at a specific address</code></pre>
<p>If an address is given, then the code must not have exceeded that address yet, and 0 bytes will be inserted to force the HUB memory to get up to the given address.</p>
<p>Note that labels normally have two values, their COG memory address (specified by the last ORG) and their hub memory address (specified implicitly by how they are placed in RAM). After <code>orgh</code> the COG memory address is no longer valid, and the hub memory address may be explicitly given if the <code>orgh</code> had a value.</p>
<h2 id="new-intrinsics-for-both-p1-and-p2">New intrinsics for both P1 and P2</h2>
<p>Flexspin supports some new builtin functions. These typically start with an underscore to avoid confusion with existing variable names. Note that in Spin2 mode many of these are available without the leading underscore, and in fact it's better to use the non-underscore versions since those are also supported in the official Parallax compiler.</p>
<h3 id="_pinw">_PINW</h3>
<p><code>_pinw(p, c)</code> forces <code>p</code> to be an output and sets it to 0 if <code>c</code> is 0 or 1 if <code>c</code> is 1. If c is any other value the result is undefined. Supported for both P1 and P2.</p>
<h3 id="_pinl">_PINL</h3>
<p><code>_pinl(p)</code> drives pin <code>p</code> low, i.e. it forces <code>p</code> to be an output and sets it to 0. This is supported for both P1 and P2.</p>
<h3 id="_pinh">_PINH</h3>
<p><code>_pinh(p)</code> drives pin <code>p</code> high, i.e. it forces <code>p</code> to be an output and sets it to 1. This is supported for both P1 and P2.</p>
<h3 id="_pinnot">_PINNOT</h3>
<p><code>_pinnot(p)</code> forces <code>p</code> to be an output and inverts it. This is supported for both P1 and P2.</p>
<h3 id="_waitx">_WAITX</h3>
<p><code>_waitx(n)</code> waits for <code>n</code> cycles, plus the cycle time required for the instruction. This is 2 cycles on P2, and 8 cycles on P1.</p>
<p>In Spin2 mode all of the above are available without the underscore.</p>
<h1 id="compatibility-with-other-spin-1-compilers">Compatibility with other Spin 1 compilers</h1>
<h2 id="limitations">Limitations</h2>
<p>Most Spin language features are supported. There may be some features that do not work; if you find any, please report them so they can be fixed.</p>
<p>The lexer and parser are different from the Parallax ones, so they may well report errors on code the Parallax compiler accepts.</p>
<h2 id="known-differences">Known Differences</h2>
<h3 id="timing">Timing</h3>
<p>Timing of produced code is different, of course (in general much faster than the native Spin interpreter). This may affect some objects; sometimes developers left out delay loops in time critical code because the Spin interpreter is so slow they weren't necessary. Watch out for this when porting I2C, SPI and similar functions.</p>
<h3 id="-and--operator-address-truncation">@ and @@ Operator address truncation</h3>
<p>The Spin1 <code>@</code> and <code>@@</code> operators always truncate their result to 16 bits; flexspin does not do this. This won't matter in typical use (on the P1 addresses always fit in 16 bits anyway) but may be noticeable for some exotic uses.</p>
<h3 id="chipver">CHIPVER</h3>
<p>The Spin1 CHIPVER command always evaluates as 1, regardless of the actual chip version stored at $FFFF.</p>
<h2 id="symbol-differences">Symbol Differences</h2>
<h3 id="local-variables-may-shadow-method-names">Local variables may shadow method names</h3>
<p>In FlexSpin local variables may have the same name as methods in the object. In the original Spin and Spin2 compilers this will produce an error. The FlexSpin way is more "traditional" (matches how most compilers/languages work).</p>
<h3 id="special-characters-in-identifiers">Special characters in identifiers</h3>
<p>Special characters like <code>$</code> may be included in Spin function and variable names by preceding them with a backquote, e.g. to define a function <code>chr$</code> do:</p>
<pre><code>  pub chr`$(x)
    return x</code></pre>
<h3 id="opcodes">Opcodes</h3>
<p>In regular Spin opcodes like <code>TEST</code> are always reserved.</p>
<p>In flexspin, opcodes are only reserved inside <code>DAT</code> sections, so it is legal to have a function or variable named <code>test</code> or <code>add</code>.</p>
<h3 id="reserved-words">Reserved words</h3>
<p>flexspin adds some reserved words: <code>asm</code>, <code>endasm</code>, and <code>then</code>. Programs which use these reserved words may not work correctly in flexspin, although there has been some effort made to make them work as regular identifiers in many contexts.</p>
<h2 id="strings">Strings</h2>
<p>Literal strings like <code>"hello"</code> are treated as lists of characters in regular Spin, unless enclosed in a <code>STRING</code> declaraction. So for example:</p>
<pre><code>    foo(&quot;ABC&quot;)</code></pre>
<p>is parsed as</p>
<pre><code>    foo(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;)</code></pre>
<p>whereas in flexspin it is treated as an array of characters, so it is parsed like:</p>
<pre><code>    foo(&quot;ABC&quot;[0])</code></pre>
<p>which will be the same as</p>
<pre><code>    foo(&quot;A&quot;)</code></pre>
<p>The difference is rarely noticeable, because flexspin does convert string literals to lists in many places.</p>
<p>As an extension, flexspin allows you to write:</p>
<pre><code>   foo(@&quot;ABC&quot;)</code></pre>
<p>instead of</p>
<pre><code>   foo(string(&quot;ABC&quot;))</code></pre>
<h2 id="known-bugs">Known Bugs</h2>
<h3 id="type-narrowing-in-assignment">Type narrowing in assignment</h3>
<p>A series of assignments like:</p>
<pre><code>  a := b := 512</code></pre>
<p>is evaluated by flexspin as</p>
<pre><code>  b := 512
  a := b</code></pre>
<p>This is sometimes different from how the official Spin1 interpreter does it. In particular, if <code>b</code> is a byte or word then the result of <code>b:=512</code> is truncated to 8 or 16 bits, whereas in the official interpreter the full 32 bit result is assigned to <code>a</code>. Thus, if <code>b</code> is a byte then flexspin sets <code>a</code> to <code>0</code> whereas Spin1 sets <code>a</code> to <code>512</code>.</p>
<p>There are some work-arounds to reduce the impact of this, so it probably will only be noticed in edge cases.</p>
<h1 id="p2-considerations">P2 Considerations</h1>
<h2 id="spin1-on-p2">Spin1 on P2</h2>
<p>Many Spin1 programs may be ported from the Propeller 1 to the Propeller 2, but there are some important exceptions:</p>
<ul>
<li><p>PASM must be translated to P2ASM. The assembly language for the Propeller 1 and Propeller 2 are different; there are some similarities, but in general any assembly language code will have to be translated to work on the different processor.</p></li>
<li><p>WAITPEQ, WAITPNE, and WAITVID are not implemented on P2</p></li>
<li><p>The hardware register set is different; the P2 does not have the CTRx, FRQx, PHSx, VCFG, or VSCL registers.</p></li>
</ul>
<h2 id="compatibility-with-proptool">Compatibility with PropTool</h2>
<p>flexspin is mostly, but not completely, compatible with the standard Spin2 compiler. Not all Spin2 builtin functions are available on the P1; only the ones listed in the "New intrinsics for both P1 and P2" are available on all platforms. But when compiling for P2 all of the Spin2 builtin functions should be available.</p>
<h3 id="layout-of-variables-in-memory">Layout of variables in memory</h3>
<p>In PropTool's Spin1 the return value always comes first in memory, followed by parameters, followed by local variables. In Spin2 this is changed, so that the parametes are first, then return values, then locals. Flexspin follows the PropTool Spin1 convention always, so that even with Spin2 code the return values are placed first. This can cause incompatibility with code that tries to copy variables using longmove, if they expect to run over the parameter / return value boundary.</p>
<h3 id="expressions-involving-">Expressions involving <code>:</code></h3>
<p>The <code>:</code> character is used in multiple conflicting ways in Spin2:</p>
<pre><code>  a ? b : 2
  x := b():1
  x := lookup(b : 1, 2)</code></pre>
<p>The flexspin parser works differently from the PNut parser, and in complicated nested expressions with multiple <code>:</code> it may not give the same results. Some tips for writing code that will work with both compilers:</p>
<ul>
<li>In general try not to nest expressions involving <code>:</code></li>
<li>Do not use <code>:</code> in <code>lookup</code>/<code>lookdown</code> type expressions except as the separator between the selection expression and the list of results</li>
<li>Make liberal use of parentheses to resolve ambiguity, e.g. write <code>a ? (b()) : 1</code> or <code>a ? (b():1) : 2</code> to distinguish between <code>:1</code> as an indirect method marker nad <code>:1</code> as the "else" part of the <code>?</code> operator.</li>
</ul>
<h3 id="-operator">@ Operator</h3>
<p>The <code>@</code> operator always gives an absolute address in flexspin's Spin2 dialect, even inside assembly code. This is different from the standard Spin2 interpreter, where it produces an address relative to the start of the current object. In most contexts the flexspin behavior is more convenient, but it is something to keep in mind.</p>
<p>If you really need a relative offset, declare a label like <code>entry</code> at the start of your assembly and use <code>@label - @entry</code> to find the offset of <code>label</code> from <code>entry</code>. This will work in all compilers.</p>
<h3 id="orgend">ORG/END</h3>
<p>No address may be given in an ORG/END pair. If no FCACHE is available (e.g. -O0 is given) then the code is run as hubexec, in which case no self-modifying code or local data is permitted.</p>
<p>The space available for use in ORG/END inline assembly is smaller by default in flexspin (128 longs) than in PNut / Proptool (304 longs). You can change the flexspin value with the <code>--fcache=</code> flag, e.g. <code>--fcache=304</code>, but beware that this may cause the COG memory to overflow if the program uses a lot of local variables or pointers.</p>
<p>The PNut / PropTool compiler has stricter limits on what registers may be used in inline assembly than flexspin does. Only the first 16 longs of the local variable area may be used in the standard compiler, whereas flexspin allows as many as will fit in memory (at least with the default PASM output).</p>
<h3 id="memory-map">Memory map</h3>
<p>The location of the clock frequency is at the standard location $14 used by TAQOZ, micropython, and most C compilers, rather than $44 as used by Spin2; similarly, clock mode is at $18 instead of $48.</p>
<p>COG memory is also laid out differently. See the general compiler documentation for details of the memory map.</p>
<h3 id="debug-statements">DEBUG statements</h3>
<p>In flexspin, <code>DEBUG</code> statements are accepted only in Spin2 methods, <em>not</em> in PASM (they are ignored in PASM). This restriction is relaxed if the P2 only <code>-gbrk</code> flag is used instead of plain <code>-g</code>.</p>
<p>Debug statements are output only when some variant of the <code>-g</code> flag (e.g. <code>-g</code> or <code>-gbrk</code> is given to flexspin.</p>
<p>Only a subset of the Spin2 <code>DEBUG</code> directives are accepted in normal <code>-g</code> mode:</p>
<pre><code>ZSTR, UDEC, UDEC_BYTE, UDEC_WORD, UDEC_LONG, SDEC, SDEC_BYTE, SDEC_WORD, SDEC_LONG, UHEX, UHEX_BYTE, UHEX_WORD, UHEX_LONG, DLY</code></pre>
<p>Other debug directives are ignored, with a warning.</p>
<p>With plain <code>-g</code> debugging <code>DEBUG</code> in flexspin is implemented differently than in PNut, so timing when debug is enabled may be different.</p>
<p><code>DEBUG</code> statements containing backticks are (partially) translated so as to output the correct strings, but FlexProp only interprets a limited subset of these strings so graphical debug capabiliites are restricted in FlexProp.</p>
<p>Thanks to Ada Gottensträter, flexspin also now supports a <code>-gbrk</code> flag to enable <code>DEBUG</code> using the standard PNut method (using a BRK) instruction. This method will work inside PASM code, and is generally more compatible with the standard PNut Spin2 code.</p>
<h3 id="asmclk-instruction">ASMCLK instruction</h3>
<p>The <code>ASMCLK</code> pseudo-instruction is supported as a preprocessor macro in FlexSpin, so only the most common spellings like <code>ASMCLK</code>, <code>AsmClk</code>, and <code>asmclk</code> will work (e.g. <code>aSmClk</code> will not work).</p>
<h3 id="regloadregexec">REGLOAD/REGEXEC</h3>
<p>The <code>REGLOAD</code> and <code>REGEXEC</code> Spin2 instructions are not supported at this time, mainly because they depend on a particular layout of memory in the Spin2 interpreter.</p>
<h3 id="detecting-flexspin-versus-pnut">Detecting FlexSpin versus PNut</h3>
<p>FlexSpin understands a special comments that start with <code>{$flexspin</code> and treats these as regular code. PNut will ignore these comments, so this provides a way to mix FlexSpin specific code and PNut specific code. See the preprocessor section above ("Special Preprocessor Comments") for further details and an example.</p>
</body>
</html>
