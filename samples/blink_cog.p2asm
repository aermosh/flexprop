con
	_clkfreq = 160000000
	_clkmode = 16779259
dat
	nop
	cogid	pa
	coginit	pa,##$404
	orgh	$10
	long	0	'reserved
	long	0 ' clock frequency: will default to 160000000
	long	0 ' clock mode: will default to $10007fb
	orgh	$400
 _ret_	mov	result1, #0
	org	0
entry
	cmp	ptra, #0 wz
 if_ne	jmp	#spininit
	mov	ptra, ptr_stackspace_
	rdlong	pa, #20 wz
 if_ne	jmp	#skip_clock_set_
	hubset	#0
	hubset	##16779256
	waitx	##200000
	mov	pa, ##16779259
	hubset	pa
	wrlong	pa, #24
	wrlong	##160000000, #20
	jmp	#skip_clock_set_
	orgf	128
skip_clock_set_
	call	#_main
cogexit
	waitx	##160000
	cogid	arg01
	cogstop	arg01
spininit
	rdlong	objptr, ptra++
	rdlong	result1, ptra++
	setq	#3
	rdlong	arg01, ptra
	sub	ptra, #4
	call	result1
	jmp	#cogexit
FCACHE_LOAD_
    pop	fcache_tmpb_
    add	fcache_tmpb_, pa
    push	fcache_tmpb_
    sub	fcache_tmpb_, pa
    shr	pa, #2
    altd	pa
    mov	 0-0, ret_instr_
    sub	pa, #1
    setq	pa
    rdlong	$0, fcache_tmpb_
    jmp	#\$0 ' jmp to cache
ret_instr_
    ret
fcache_tmpb_
    long 0
builtin_bytefill_
        shr	arg03, #1 wc
 if_c   wrbyte	arg02, arg01
 if_c   add	arg01, #1
        movbyts	arg02, #0
builtin_wordfill_
        shr	arg03, #1 wc
 if_c   wrword	arg02, arg01
 if_c   add	arg01, #2
        setword	arg02, arg02, #1
builtin_longfill_
        wrfast	#0,arg01
        cmp	arg03, #0 wz
 if_nz  rep	#1, arg03
 if_nz  wflong	arg02
        ret
COUNT_
    long 0
RETADDR_
    long 0
fp
    long 0
pushregs_
    pop  pa
    pop  RETADDR_
    tjz  COUNT_, #pushregs_done_
    altd  COUNT_, #511
    setq #0-0
    wrlong local01, ptra++
pushregs_done_
    setq #2 ' push 3 registers starting at COUNT_
    wrlong COUNT_, ptra++
    mov    fp, ptra
    jmp  pa
 popregs_
    pop    pa
    setq   #2
    rdlong COUNT_, --ptra
    djf    COUNT_, #popregs__ret
    setq   COUNT_
    rdlong local01, --ptra
popregs__ret
    push   RETADDR_
    jmp    pa

divide_
       abs     muldivb_,muldivb_     wcz      'abs(y)
       wrc     itmp2_                         'store sign of y
       abs     muldiva_,muldiva_     wc       'abs(x)
       qdiv    muldiva_, muldivb_             'queue divide
 if_c  xor     itmp2_,#1                      'store sign of x
       getqx   muldivb_                       'get quotient
       getqy   muldiva_                       'get remainder
       negc    muldiva_,muldiva_              'restore sign, remainder (sign of x)
       testb   itmp2_,#0             wc       'restore sign, division result
 _ret_ negc    muldivb_,muldivb_     

entryptr__
	long	@entry
itmp1_
	long	0
itmp2_
	long	0
objptr
	long	@objmem
ptr___system__dat__
	long	@__system__dat_
ptr__blink_
	long	@_blink
ptr__dat__
	long	@_dat_
ptr_stackspace_
	long	@stackspace
result1
	long	0
result2
	long	1
COG_BSS_START
	fit	480
	orgh
hubentry

_blink
	rdlong	_var01, arg01
	add	arg01, #4
	rdlong	arg01, arg01
' 
' 
'     for(;;) {
	loc	pa,	#(@LR__0003-@LR__0001)
	call	#FCACHE_LOAD_
LR__0001
	rep	@LR__0004, #0
LR__0002
	drvnot	_var01
	waitx	arg01
LR__0003
LR__0004
_blink_ret
	ret

_main
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #12
	wrlong	#56, fp
	add	fp, #4
	wrlong	##40000000, fp
	sub	fp, #4
	mov	arg01, ptr__dat__
	wrlong	objptr, arg01
	add	arg01, #4
	wrlong	ptr__blink_, arg01
	add	arg01, #4
	wrlong	fp, arg01
	mov	arg02, entryptr__
	mov	arg03, ptr__dat__
	mov	arg04, #30
	setq	arg03
	coginit	arg04, arg02 wc
 if_b	neg	arg04, #1
	add	fp, #8
	wrlong	arg04, fp
	sub	fp, #8
	add	ptr___system__dat__, #28
	mov	arg01, ptr___system__dat__
	sub	ptr___system__dat__, #28
	call	#__system___lockmem
	mov	arg02, ##@LR__0110
	mov	arg01, #0
	mov	arg03, #0
	mov	arg04, arg02 wz
 if_ne	mov	arg02, #0
 if_ne	mov	arg03, arg04
 if_ne	mov	arg01, #1
 if_ne	call	#__system___fmtstr
	add	fp, #8
	rdlong	arg03, fp
	sub	fp, #8
	mov	arg04, #10
	mov	arg02, #0
	mov	arg01, #1
	call	#__system___fmtnum
	mov	arg02, ##@LR__0111
	mov	arg01, #0
	mov	arg03, #0
	mov	arg04, arg02 wz
 if_ne	mov	arg02, #0
 if_ne	mov	arg03, arg04
 if_ne	mov	arg01, #1
 if_ne	call	#__system___fmtstr
	rdlong	arg03, fp
	mov	arg04, #10
	mov	arg02, #0
	mov	arg01, #1
	call	#__system___fmtnum
	mov	arg01, #10
	call	#__system___tx
	add	ptr___system__dat__, #28
	wrlong	#0, ptr___system__dat__
' 
' 
'     for(;;)
LR__0010
	jmp	#LR__0010
	mov	ptra, fp
	call	#popregs_
_main_ret
	ret
hubexit
	jmp	#cogexit

__system___setbaud
	rdlong	muldiva_, #20
	mov	muldivb_, arg01
	call	#divide_
	loc	pa,	#(@LR__0021-@LR__0020)
	call	#FCACHE_LOAD_
LR__0020
	mov	result1, #0
	rdpin	result1, #62 wc
	subx	result2, result2
 if_b	jmp	#LR__0020
LR__0021
	dirl	#62
	dirl	#63
	wrlong	muldivb_, ptr___system__dat__
	shl	muldivb_, #16
	mov	arg02, #7
	add	arg02, muldivb_
	wrpin	#124, #62
	wxpin	arg02, #62
	wrpin	#62, #63
	add	arg02, #20
	wxpin	arg02, #63
	dirh	#62
	dirh	#63
__system___setbaud_ret
	ret

__system___txraw
	mov	COUNT_, #1
	call	#pushregs_
	mov	local01, arg01
	loc	pa,	#(@LR__0031-@LR__0030)
	call	#FCACHE_LOAD_
LR__0030
	mov	result1, #0
	rdpin	result1, #62 wc
	subx	result2, result2
 if_b	jmp	#LR__0030
LR__0031
	rdlong	result1, ptr___system__dat__ wz
 if_e	mov	arg01, ##230400
 if_e	call	#__system___setbaud
	wypin	local01, #62
	mov	result1, #1
	mov	ptra, fp
	call	#popregs_
__system___txraw_ret
	ret

__system___lockmem
	mov	result1, #0
	cogid	result1
	add	result1, #256
LR__0040
	rdlong	_var01, arg01 wz
 if_e	wrlong	result1, arg01
 if_e	rdlong	_var01, arg01
 if_e	rdlong	_var01, arg01
	cmp	_var01, result1 wz
 if_ne	jmp	#LR__0040
__system___lockmem_ret
	ret

__system___tx
	mov	COUNT_, #2
	call	#pushregs_
	mov	local01, arg01
	cmp	local01, #10 wz
 if_ne	jmp	#LR__0050
	add	ptr___system__dat__, #8
	rdlong	local02, ptr___system__dat__
	sub	ptr___system__dat__, #8
	test	local02, #2 wz
 if_ne	mov	arg01, #13
 if_ne	call	#__system___txraw
LR__0050
	mov	arg01, local01
	call	#__system___txraw
	mov	ptra, fp
	call	#popregs_
__system___tx_ret
	ret

__system___fmtchar
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #16
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #4
	wrlong	arg02, fp
	add	fp, #4
	wrlong	arg03, fp
	getbyte	arg03, arg03, #0
	wrlong	arg03, fp
	sub	fp, #8
	rdlong	arg01, fp
	add	fp, #4
	rdlong	arg02, fp
	add	fp, #4
	mov	arg03, fp
	sub	fp, #12
	call	#__system___fmtstr
	mov	ptra, fp
	call	#popregs_
__system___fmtchar_ret
	ret

__system___fmtstr
	mov	COUNT_, #6
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, arg03
	getbyte	arg04, local02, #0
	mov	arg01, local03
	mov	local04, #0
	loc	pa,	#(@LR__0061-@LR__0060)
	call	#FCACHE_LOAD_
LR__0060
	rdbyte	result1, arg01 wz
 if_ne	add	local04, #1
 if_ne	add	arg01, #1
 if_ne	jmp	#LR__0060
LR__0061
	cmp	arg04, #0 wz
 if_ne	fles	local04, arg04 wcz
	mov	arg02, local02
	mov	arg03, local04
	mov	arg01, local01
	mov	arg04, #2
	call	#__system___fmtpad
	mov	local05, result1
	cmps	local05, #0 wc
 if_b	mov	result1, local05
 if_b	jmp	#LR__0064
	mov	local06, #0
LR__0062
	cmps	local06, local04 wc
 if_ae	jmp	#LR__0063
	rdbyte	arg01, local03
	add	local03, #1
	call	#__system___tx
	add	local05, #1
	add	local06, #1
	jmp	#LR__0062
LR__0063
	mov	arg02, local02
	mov	arg03, local04
	mov	arg01, local01
	mov	arg04, #1
	call	#__system___fmtpad
	mov	local06, result1
	cmps	local06, #0 wc
 if_b	mov	result1, local06
 if_ae	add	local05, local06
 if_ae	mov	result1, local05
LR__0064
	mov	ptra, fp
	call	#popregs_
__system___fmtstr_ret
	ret

__system___fmtnum
	mov	COUNT_, #11
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, arg03
	mov	local04, arg04
	mov	local05, ptra
	mov	local06, local05
	mov	local07, #0
	mov	local08, local02
	shr	local08, #16
	and	local08, #63
	getbyte	local09, local02, #0
	mov	local10, local02
	shr	local10, #26
	and	local10, #3
	mov	local11, local10
	cmps	local08, #1 wc
	add	ptra, #68
 if_ae	mov	local10, local08
 if_ae	sub	local10, #1
 if_ae	mov	local08, local10
	cmps	local09, #65 wc
 if_b	cmp	local09, #0 wz
 if_nc_or_z	mov	local09, #64
	cmp	local11, #3 wz
 if_e	mov	local11, #0
 if_ne	cmps	local03, #0 wc
 if_c_and_nz	mov	local11, #4
 if_c_and_nz	neg	local03, local03
	cmp	local11, #0 wz
 if_e	jmp	#LR__0073
	mov	local07, #1
	cmp	local08, local09 wz
 if_ne	jmp	#LR__0071
	djnz	local08, #LR__0070
	mov	arg01, local01
	mov	arg02, local02
	mov	arg03, #35
	call	#__system___fmtchar
	jmp	#LR__0077
LR__0070
LR__0071
	cmp	local11, #2 wz
 if_e	mov	local10, local06
 if_e	add	local06, #1
 if_e	wrbyte	#32, local10
 if_e	jmp	#LR__0072
	cmp	local11, #4 wz
 if_e	wrbyte	#45, local06
 if_e	add	local06, #1
 if_ne	wrbyte	#43, local06
 if_ne	add	local06, #1
LR__0072
LR__0073
	mov	arg01, local06
	mov	arg02, local03
	mov	arg03, local04
	mov	arg04, local08
	mov	arg05, #0
	testbn	local02, #29 wz
 if_ne	mov	arg05, #1
	call	#__system___uitoa
	add	local07, result1
	cmps	local07, local09 wcz
 if_be	jmp	#LR__0076
	loc	pa,	#(@LR__0075-@LR__0074)
	call	#FCACHE_LOAD_
LR__0074
	mov	local10, local09
	cmps	local10, #1 wc
	sub	local09, #1
 if_ae	mov	local10, local06
 if_ae	add	local06, #1
 if_ae	wrbyte	#35, local10
 if_ae	jmp	#LR__0074
LR__0075
	wrbyte	#0, local06
LR__0076
	mov	arg02, local02
	mov	arg03, local05
	mov	arg01, local01
	call	#__system___fmtstr
LR__0077
	mov	ptra, fp
	call	#popregs_
__system___fmtnum_ret
	ret

__system___strrev
	rdbyte	_var01, arg01 wz
 if_e	jmp	#__system___strrev_ret
	mov	_var02, arg01
	loc	pa,	#(@LR__0082-@LR__0080)
	call	#FCACHE_LOAD_
LR__0080
	rdbyte	_var01, _var02 wz
 if_ne	add	_var02, #1
 if_ne	jmp	#LR__0080
	sub	_var02, #1
LR__0081
	cmps	_var02, arg01 wcz
 if_be	jmp	#LR__0083
	rdbyte	_var01, arg01
	rdbyte	_var03, _var02
	wrbyte	_var03, arg01
	wrbyte	_var01, _var02
	add	arg01, #1
	sub	_var02, #1
	jmp	#LR__0081
LR__0082
LR__0083
__system___strrev_ret
	ret

__system___fmtpad
	mov	COUNT_, #4
	call	#pushregs_
	mov	local01, arg02
	mov	local02, arg03
	getbyte	arg01, local01, #1
	shr	local01, #22
	and	local01, #3 wz
	mov	local03, #0
 if_e	mov	local01, #1
	test	local01, arg04 wz
 if_e	mov	result1, #0
 if_e	jmp	#LR__0093
	subr	local02, arg01
	cmps	local02, #1 wc
 if_b	mov	result1, #0
 if_b	jmp	#LR__0093
	cmp	local01, #3 wz
 if_ne	jmp	#LR__0090
	cmp	arg04, #1 wz
	wrz	local01
	add	local02, local01
	abs	local02, local02 wc
	shr	local02, #1
	negc	local02, local02
LR__0090
	mov	local04, #0
LR__0091
	cmps	local04, local02 wc
 if_ae	jmp	#LR__0092
	mov	arg01, #32
	call	#__system___tx
	add	local03, #1
	add	local04, #1
	jmp	#LR__0091
LR__0092
	mov	result1, local03
LR__0093
	mov	ptra, fp
	call	#popregs_
__system___fmtpad_ret
	ret

__system___uitoa
	mov	COUNT_, #8
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, arg03
	mov	local04, arg04
	mov	local05, arg05 wz
	mov	local06, local01
	mov	local07, #0
 if_ne	mov	local08, #55
 if_e	mov	local08, #87
LR__0100
	qdiv	local02, local03
	getqy	local05
	qdiv	local02, local03
	cmp	local05, #10 wc
 if_b	add	local05, #48
 if_ae	add	local05, local08
	wrbyte	local05, local06
	add	local06, #1
	add	local07, #1
	getqx	local02
	cmp	local02, #0 wz
 if_ne	jmp	#LR__0100
	cmp	local07, local04 wc
 if_b	jmp	#LR__0100
	wrbyte	#0, local06
	mov	arg01, local01
	call	#__system___strrev
	mov	result1, local07
	mov	ptra, fp
	call	#popregs_
__system___uitoa_ret
	ret

LR__0110
	byte	"started cog "
	byte	0
LR__0111
	byte	" to blink pin "
	byte	0
	alignl
_dat_
	byte	$00[256]
	alignl
__system__dat_
	byte	$00[8]
	byte	$03, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $00, $00, $00, $00, $00, $00, $00
objmem
	long	0[0]
stackspace
	long	0[1]
	org	COG_BSS_START
_var01
	res	1
_var02
	res	1
_var03
	res	1
arg01
	res	1
arg02
	res	1
arg03
	res	1
arg04
	res	1
arg05
	res	1
local01
	res	1
local02
	res	1
local03
	res	1
local04
	res	1
local05
	res	1
local06
	res	1
local07
	res	1
local08
	res	1
local09
	res	1
local10
	res	1
local11
	res	1
muldiva_
	res	1
muldivb_
	res	1
	fit	480
